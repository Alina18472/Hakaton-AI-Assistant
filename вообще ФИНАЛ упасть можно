import torch
from transformers import DistilBertTokenizer, DistilBertForSequenceClassification
from sentence_transformers import SentenceTransformer, util
import pandas as pd
import tkinter as tk
import os
import docx

# Load data and create service names
data = pd.read_excel('dataset.xlsx')
texts = data['Topic'].tolist()
sbert_model = SentenceTransformer('all-MiniLM-L6-v2')
text_embeddings = sbert_model.encode(texts, convert_to_tensor=True)
service_names = list(data['label'].astype('category').cat.categories)

# Load the trained model and tokenizer
tokenizer = DistilBertTokenizer.from_pretrained("enhanced_trained_model")
model = DistilBertForSequenceClassification.from_pretrained("enhanced_trained_model")

# Instructions from dataset
instructions = data['Solution'].dropna().tolist()
instructions = [str(instruction) for instruction in instructions]
instruction_embeddings = sbert_model.encode(instructions, convert_to_tensor=True)

# Function to create a yellow label with black border
def create_styled_label(parent, text):
    canvas = tk.Canvas(parent, width=300, height=50, bg='yellow', highlightthickness=0)
    canvas.create_rectangle(0, 0, 300, 50, fill='yellow', outline='black', width=2)
    canvas.create_text(150, 25, text=text, fill='black', font=("Arial", 12))
    canvas.pack(pady=5)

# Function to find top N similar Word files
def find_top_files(instruction_text, top_n=3):
    folder_path = 'Instructions'
    instruction_embedding = sbert_model.encode(instruction_text, convert_to_tensor=True)

    similarities = []
    for filename in os.listdir(folder_path):
        if filename.endswith('.docx') and not filename.startswith('~$'):
            doc_path = os.path.join(folder_path, filename)
            try:
                doc = docx.Document(doc_path)
                full_text = '\n\n'.join([para.text for para in doc.paragraphs if para.text.strip()])
                doc_embedding = sbert_model.encode(full_text, convert_to_tensor=True)
                score = util.pytorch_cos_sim(instruction_embedding, doc_embedding).item()
                similarities.append((score, filename))
            except Exception as e:
                print(f"Error reading {filename}: {e}")

    top_files = sorted(similarities, key=lambda x: x[0], reverse=True)[:top_n]
    return [filename for score, filename in top_files]

# Function to display buttons for top instruction files
def show_instruction_buttons(top_files):
    clear_instruction_buttons()

    for idx, filename in enumerate(top_files):
        button_text = f"Open Instruction {idx + 1} ({'Most likely' if idx == 0 else 'Related'})"
        button = tk.Button(result_frame, text=button_text,
                           command=lambda f=filename: os.startfile(os.path.join('Instructions', f)))
        button.pack()

# Function to analyze the problem and display results
def analyze_problem(problem_text):
    try:
        inputs = tokenizer(problem_text, return_tensors="pt", truncation=True, padding="max_length", max_length=64)
        outputs = model(**inputs)
        softmaxed = torch.nn.functional.softmax(outputs.logits, dim=-1)
        top_probs, top_indices = torch.topk(softmaxed, k=3)

        top_services = [(service_names[idx], prob.item() * 100) for idx, prob in zip(top_indices[0], top_probs[0])]

        query_embedding = sbert_model.encode(problem_text, convert_to_tensor=True)
        cos_sim = util.pytorch_cos_sim(query_embedding, text_embeddings)
        top_similarities, top_indices = torch.topk(cos_sim[0], k=min(5, len(texts)))
        top_problems = [(texts[idx.item()], round(sim.item() * 100, 2)) for idx, sim in zip(top_indices, top_similarities)]
    except Exception as e:
        clear_results()
        tk.Label(result_frame, text=f"Error during analysis: {e}", bg='lightgray').pack()
        return

    try:
        instruction_cos_sim = util.pytorch_cos_sim(query_embedding, instruction_embeddings)
        best_instruction_idx = torch.argmax(instruction_cos_sim).item()
        best_instruction = instructions[best_instruction_idx] if pd.notnull(instructions[best_instruction_idx]) else "No instruction found."
    except Exception as e:
        best_instruction = "Error retrieving instruction: " + str(e)

    clear_results()

    create_styled_label(result_frame, "Service suggestions:")
    for i, (service, prob) in enumerate(top_services[:3]):
        tk.Label(result_frame, text=f"{i + 1}. {service}: {prob:.2f}%", bg='lightgray', font=("Arial", 12)).pack()

    create_styled_label(result_frame, "Most similar problems:")
    for problem_idx, (problem, percentage) in enumerate(top_problems[:3]):
        dataset_index = top_indices[problem_idx].item()
        tk.Label(result_frame, text=f"{dataset_index + 1}. {problem} ({percentage}%)", bg='lightgray', font=("Arial", 12)).pack()

    create_styled_label(result_frame, "Suggested instruction:")
    tk.Label(result_frame, text=f"{best_instruction}", bg='lightgray', font=("Arial", 12)).pack()

    detailed_button = tk.Button(result_frame, text="View Detailed Instructions",
                                command=lambda: show_instruction_buttons(find_top_files(best_instruction, top_n=3)),
                                bg='yellow')
    detailed_button.pack()

def clear_results():
    for widget in result_frame.winfo_children():
        widget.destroy()

def clear_instruction_buttons():
    for widget in result_frame.winfo_children():
        if isinstance(widget, tk.Button) and widget.cget("text").startswith("Open Instruction"):
            widget.destroy()

# Tkinter GUI setup
window = tk.Tk()
window.title("Problem Analyzer")
window.configure(bg='dimgray')  # Dark gray background for the window

# Set window size
window_width = 800  # Fixed width
window_height = 600  # Fixed height
window.geometry(f"{window_width}x{window_height}")

# Create a frame for the left panel
left_frame = tk.Frame(window, bg='lightgray', width=400)  # Fixed width for left panel
left_frame.pack(side=tk.LEFT, fill=tk.Y)

# Create a frame for results
result_frame = tk.Frame(left_frame, bg='lightgray')
result_frame.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

# Create the input areay
input_frame = tk.Frame(window, bg='dimgray', width=400)  # Fixed width for input area
input_frame.pack(pady=(10, 60))  # Right side for input area

label_problem = tk.Label(input_frame, text="Enter your problem description:", bg='dimgray', fg='white')
label_problem.pack(pady=(10, 60))

entry_problem = tk.Entry(input_frame, width=50)
entry_problem.pack(pady=(10, 60))

button_analyze = tk.Button(input_frame, text="Analyze", command=lambda: analyze_problem(entry_problem.get()))
button_analyze.pack(pady=(10, 40))

label_result = tk.Label(input_frame, text="Result:", bg='dimgray', fg='white')
label_result.pack()

window.mainloop()
